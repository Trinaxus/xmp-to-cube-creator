import type { LUTSize, ColorSpace } from '@/types/lut';
import type { XMPColorSettings } from './xmp-parser';
import { transformColor } from './color-transform';

interface LUTPoint {
  r: number;
  g: number;
  b: number;
  outR: number;
  outG: number;
  outB: number;
}

// Default settings when no XMP is provided
const defaultSettings: XMPColorSettings = {
  exposure: 0,
  contrast: 0,
  highlights: 0,
  shadows: 0,
  whites: 0,
  blacks: 0,
  clarity: 0,
  dehaze: 0,
  texture: 0,
  vibrance: 0,
  saturation: 0,
  temperature: 0,
  tint: 0,
  hsl: {
    hue: { red: 0, orange: 0, yellow: 0, green: 0, aqua: 0, blue: 0, purple: 0, magenta: 0 },
    saturation: { red: 0, orange: 0, yellow: 0, green: 0, aqua: 0, blue: 0, purple: 0, magenta: 0 },
    luminance: { red: 0, orange: 0, yellow: 0, green: 0, aqua: 0, blue: 0, purple: 0, magenta: 0 },
  },
  splitToning: {
    shadowHue: 0,
    shadowSaturation: 0,
    highlightHue: 0,
    highlightSaturation: 0,
    balance: 0,
  },
  toneCurve: {
    points: [[0, 0], [255, 255]],
    red: [[0, 0], [255, 255]],
    green: [[0, 0], [255, 255]],
    blue: [[0, 0], [255, 255]],
  },
};

// Apply log encoding for log-based color spaces
function applyLogEncoding(value: number, colorSpace: ColorSpace): number {
  if (colorSpace === 'log_slog3') {
    // Sony S-Log3 encoding
    if (value >= 0.01125) {
      return (420 + Math.log10((value + 0.01) / 0.19) * 261.5) / 1023;
    }
    return (value * 171.2102946929 + 95) / 1023;
  }
  
  if (colorSpace === 'log_vlog') {
    // Panasonic V-Log encoding
    if (value >= 0.01) {
      return 0.241514 + 0.598206 * Math.log10(value + 0.00873);
    }
    return 5.6 * value + 0.125;
  }
  
  if (colorSpace === 'log_clog') {
    // Canon Log encoding
    if (value >= 0) {
      return 0.529136 + 0.169 * Math.log10(value + 0.0730597);
    }
    return value;
  }
  
  return value;
}

export function generateLUTData(
  size: LUTSize,
  colorSpace: ColorSpace,
  clamp: boolean,
  settings?: XMPColorSettings
): LUTPoint[] {
  const sizeNum = parseInt(size);
  const points: LUTPoint[] = [];
  const xmpSettings = settings || defaultSettings;
  
  for (let b = 0; b < sizeNum; b++) {
    for (let g = 0; g < sizeNum; g++) {
      for (let r = 0; r < sizeNum; r++) {
        const inR = r / (sizeNum - 1);
        const inG = g / (sizeNum - 1);
        const inB = b / (sizeNum - 1);
        
        // Apply color transformation based on XMP settings
        let [outR, outG, outB] = transformColor(inR, inG, inB, xmpSettings);
        
        // Apply log encoding if needed
        if (colorSpace.startsWith('log_')) {
          outR = applyLogEncoding(outR, colorSpace);
          outG = applyLogEncoding(outG, colorSpace);
          outB = applyLogEncoding(outB, colorSpace);
        }
        
        if (clamp) {
          outR = Math.max(0, Math.min(1, outR));
          outG = Math.max(0, Math.min(1, outG));
          outB = Math.max(0, Math.min(1, outB));
        }
        
        points.push({
          r: inR,
          g: inG,
          b: inB,
          outR,
          outG,
          outB,
        });
      }
    }
  }
  
  return points;
}

export function generateCubeFile(
  presetName: string,
  size: LUTSize,
  colorSpace: ColorSpace,
  variantName: string,
  clamp: boolean,
  settings?: XMPColorSettings
): string {
  const sizeNum = parseInt(size);
  const points = generateLUTData(size, colorSpace, clamp, settings);
  
  let content = '';
  
  // Header
  content += `# LUT generated by LUT Forge\n`;
  content += `# Source: ${presetName}\n`;
  content += `# Color Space: ${colorSpace}\n`;
  content += `# Variant: ${variantName}\n`;
  content += `# Generated: ${new Date().toISOString()}\n`;
  content += `\n`;
  content += `TITLE "${presetName}_${variantName}"\n`;
  content += `LUT_3D_SIZE ${sizeNum}\n`;
  content += `DOMAIN_MIN 0.0 0.0 0.0\n`;
  content += `DOMAIN_MAX 1.0 1.0 1.0\n`;
  content += `\n`;
  
  // LUT data
  for (const point of points) {
    content += `${point.outR.toFixed(6)} ${point.outG.toFixed(6)} ${point.outB.toFixed(6)}\n`;
  }
  
  return content;
}

export function downloadCubeFile(
  content: string,
  filename: string
): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
