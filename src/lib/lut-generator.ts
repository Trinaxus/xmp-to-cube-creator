import type { LUTSize, ColorSpace } from '@/types/lut';

interface LUTPoint {
  r: number;
  g: number;
  b: number;
  outR: number;
  outG: number;
  outB: number;
}

// Simulated color transformation based on common XMP adjustments
// In a real implementation, this would sample the actual Lightroom output
function simulateColorTransform(
  r: number,
  g: number,
  b: number,
  colorSpace: ColorSpace
): [number, number, number] {
  // Apply a simulated "cinematic" look
  // This is a placeholder - real implementation would use sampled data
  
  // Slight warm shift
  let outR = r * 1.05;
  let outG = g * 1.0;
  let outB = b * 0.92;
  
  // Lift shadows slightly
  const shadowLift = 0.02;
  outR = outR + (1 - outR) * shadowLift * (1 - r);
  outG = outG + (1 - outG) * shadowLift * (1 - g);
  outB = outB + (1 - outB) * shadowLift * (1 - b);
  
  // Slight S-curve contrast
  const contrast = (value: number) => {
    return 0.5 + (value - 0.5) * 1.1;
  };
  
  outR = contrast(outR);
  outG = contrast(outG);
  outB = contrast(outB);
  
  // Color space specific adjustments
  if (colorSpace.startsWith('log_')) {
    // Apply inverse log for log input
    const logToLinear = (v: number) => Math.pow(10, (v - 0.385) * 5.26) * 0.18;
    outR = logToLinear(outR);
    outG = logToLinear(outG);
    outB = logToLinear(outB);
  }
  
  // Clamp to valid range
  outR = Math.max(0, Math.min(1, outR));
  outG = Math.max(0, Math.min(1, outG));
  outB = Math.max(0, Math.min(1, outB));
  
  return [outR, outG, outB];
}

export function generateLUTData(
  size: LUTSize,
  colorSpace: ColorSpace,
  clamp: boolean
): LUTPoint[] {
  const sizeNum = parseInt(size);
  const points: LUTPoint[] = [];
  
  for (let b = 0; b < sizeNum; b++) {
    for (let g = 0; g < sizeNum; g++) {
      for (let r = 0; r < sizeNum; r++) {
        const inR = r / (sizeNum - 1);
        const inG = g / (sizeNum - 1);
        const inB = b / (sizeNum - 1);
        
        let [outR, outG, outB] = simulateColorTransform(inR, inG, inB, colorSpace);
        
        if (clamp) {
          outR = Math.max(0, Math.min(1, outR));
          outG = Math.max(0, Math.min(1, outG));
          outB = Math.max(0, Math.min(1, outB));
        }
        
        points.push({
          r: inR,
          g: inG,
          b: inB,
          outR,
          outG,
          outB,
        });
      }
    }
  }
  
  return points;
}

export function generateCubeFile(
  presetName: string,
  size: LUTSize,
  colorSpace: ColorSpace,
  variantName: string,
  clamp: boolean
): string {
  const sizeNum = parseInt(size);
  const points = generateLUTData(size, colorSpace, clamp);
  
  let content = '';
  
  // Header
  content += `# LUT generated by LUT Forge\n`;
  content += `# Source: ${presetName}\n`;
  content += `# Color Space: ${colorSpace}\n`;
  content += `# Variant: ${variantName}\n`;
  content += `# Generated: ${new Date().toISOString()}\n`;
  content += `\n`;
  content += `TITLE "${presetName}_${variantName}"\n`;
  content += `LUT_3D_SIZE ${sizeNum}\n`;
  content += `DOMAIN_MIN 0.0 0.0 0.0\n`;
  content += `DOMAIN_MAX 1.0 1.0 1.0\n`;
  content += `\n`;
  
  // LUT data
  for (const point of points) {
    content += `${point.outR.toFixed(6)} ${point.outG.toFixed(6)} ${point.outB.toFixed(6)}\n`;
  }
  
  return content;
}

export function downloadCubeFile(
  content: string,
  filename: string
): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
